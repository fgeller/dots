* ivy

  Load ivy and friends.

  #+begin_src emacs-lisp
    (use-package ivy :ensure swiper)
    (use-package counsel :ensure counsel)
    (use-package recentf)
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (use-package seq)
  #+end_src

  Helpers work with candidate strings.

  #+begin_src emacs-lisp
    (defun strip-text-properties (txt)
      "Removes text properties from TXT"
      (set-text-properties 0 (length txt) nil txt)
      txt)

    (defun add-ivy-action (str action)
      "Adds ACTION as text-property to start of STR"
      (put-text-property 0 1 'ivy-action action str))

    (defun get-ivy-action (str)
      "Returns text-property `ivy-action' at start of STR"
      (get-text-property 0 'ivy-action str))

    (defun string-copy (str)
      "Uses `substring' to return a copy of STR without text properties"
      (substring str 0 (length str)))

    (defun ivy-add-actions (candidates action)
      "Copies each entry in CANDIDATES and adds ACTION as a text property to it"
      (mapcar (lambda (bn)
                (let ((c (string-copy bn)))
                  (add-ivy-action c action)
                  c))
              candidates))
  #+end_src

  Monkey-patch till upstream is customizable.

  #+begin_src emacs-lisp
    (defun enable-ivy-calling ()
      (setq ivy-calling t))

    (defmacro with-ivy-calling (&rest body)
      `(unwind-protect
           (progn
             (advice-add 'ivy--minibuffer-setup :before 'enable-ivy-calling)
             ,@body)
         (advice-remove 'ivy--minibuffer-setup 'enable-ivy-calling)))
  #+end_src

  apropos helper with ivy completion magic.

  #+begin_src emacs-lisp
    (defun ivy-apropos-candidates ()
      (let ((start-time (current-time))
            cs)
        (mapatoms
         (lambda (e)
           (let* ((n (symbol-name e))
                  (c (substring n 0 (length n)))) ; cheap copying r/o values
             (cond
              ((fboundp e)
               (add-ivy-action c 'describe-function)
               (push c cs))
              ((or (get e 'variable-documentation)
                   (and (boundp e) (not (keywordp e))))
               (add-ivy-action c 'describe-variable)
               (push c cs))))))
        (message "it took [%s]ms to compute [%s] apropos candidates"
                 (format-time-string "%3N" (time-subtract (current-time) start-time))
                 (length cs))
        cs))

    (defun ivy-apropos ()
      (interactive)
      (ivy-read "Describe: " (ivy-apropos-candidates)
       :initial-input (thing-at-point 'symbol)
       :action (lambda (s) (funcall (get-ivy-action s) (intern s)))))
  #+end_src

  Modified version of counsel-ag.

  #+begin_src emacs-lisp
    (defun ivy-ag-function (string)
      "Grep in the current directory for STRING."
      (if (< (length string) 3)
          (counsel-more-chars 3)
        (let* ((default-directory counsel--git-grep-dir)
               (regex (counsel-unquote-regex-parens
                       (setq ivy--old-re
                             (ivy--regex string))))
               ;; TODO create temp file when no file associated?
               (fn (with-ivy-window (file-relative-name (buffer-file-name) counsel--git-grep-dir)))
               (cmd (format "ag --vimgrep %s -- %s && (ag --ignore %s --vimgrep %s || exit 0)"
                             (shell-quote-argument regex)
                             (shell-quote-argument fn)
                             (shell-quote-argument fn)
                             (shell-quote-argument regex))))
          (counsel--async-command cmd)
          nil)))

    (defun ivy-ag-with-thing-at-point ()
      "ag with thing at point, preselecting match where point is and defaulting to current git root."
      (interactive)
      (with-ivy-calling
       (let ((init-dir (or (locate-dominating-file default-directory ".git")
                           default-directory))
             (tap (strip-text-properties (thing-at-point 'symbol))))
         (setq counsel--git-grep-dir init-dir)
         (ivy-read "ag: " 'ivy-ag-function
                   :initial-input tap
                   :dynamic-collection t
                   :history 'counsel-git-grep-history
                   :action #'counsel-git-grep-action
                   :preselect
                   (with-ivy-window
                     (format "%s:%s:"
                             (file-name-nondirectory (buffer-file-name))
                             (line-number-at-pos)))
                   :unwind (lambda ()
                             (counsel-delete-process)
                             (swiper--cleanup))))))
  #+end_src

  Helper to jump to things that I often jump to.

  #+begin_src emacs-lisp
    (defun git-ls-files ()
      (let ((grt (locate-dominating-file default-directory ".git")))
        (when grt
          (let* ((default-directory grt))
            (split-string (shell-command-to-string "git ls-files --full-name --") "\n" t)))))

    (defun ivy-git-files-candidates ()
      (let ((bfns (mapcar 'buffer-file-name (buffer-list))))
        (ivy-add-actions
         (cl-remove-if (lambda (gf) (member gf bfns)) (git-ls-files))
         (lambda (n) (with-ivy-window
                       (let ((grt (locate-dominating-file default-directory ".git"))
                             (inhibit-message t))
                         (find-file (expand-file-name n grt))))))))

    (defun ivy-buffer-name-candidates ()
      (ivy-add-actions
       (remove-if (lambda (c) (string-match (regexp-quote "*Minibuf-") c))
                  (mapcar 'buffer-name (buffer-list)))
       (lambda (n) (with-ivy-window (switch-to-buffer n nil 'force-same-window)))))

    (defun ivy-org-heading-action (f)
      (lexical-let ((fn f))
        (lambda (c)
          (with-ivy-window
            (find-file fn)
            (goto-char (point-min))
            (re-search-forward (concat "^" (regexp-quote c)))
            (org-beginning-of-line)
            (recenter-top-bottom)))))

    (defun ivy-org-heading-candidates ()
      (apply (lambda (ls) (seq-concatenate 'list ls))
       (mapcar
        (lambda (b)
          (let ((cs (with-temp-buffer
                      (insert (with-current-buffer (find-file-noselect b) (buffer-string)))
                      (keep-lines org-heading-regexp (point-min) (point-max))
                      (mapcar 'strip-text-properties
                              (split-string (buffer-string) "\n" t "[      ]*")))))
            (ivy-add-actions cs (ivy-org-heading-action b))))
        (org-agenda-files))))

    (defun ivy-recentf-candidates ()
      (ivy-add-actions recentf-list 'find-file))

    (defun ivy-jump-candidates ()
      "Returns a list of candidates for jumping to with associated actions as text properties"
      (let* ((start-time (current-time))
             (bufs (ivy-buffer-name-candidates))
             (gfs (ivy-git-files-candidates))
             (rfs (ivy-recentf-candidates))
             (ohs (ivy-org-heading-candidates))
             (cs (seq-concatenate 'list bufs gfs ohs rfs))
             (elapsed (time-subtract (current-time) start-time)))
        (message "it took [%s]ms to compute [%s] jump candidates"
                 (format-time-string "%3N" elapsed)
                 (length cs))
        cs))

    (defun ivy-jump ()
      "ivy completion for common jump targets (buffers, git-ls-files, recentf)"
      (interactive)
      (with-ivy-calling
       (ivy-read "jump "
                 (ivy-jump-candidates)
                 :preselect (buffer-name (other-buffer (current-buffer)))
                 :action (lambda (c) (funcall (get-ivy-action c) c)))))
  #+end_src

  Helper to jump to my projects

  #+begin_src emacs-lisp
    (defun ivy-jump-to-project-candidates ()
      (let* ((ps (seq-concatenate
                  'list
                  (mapcar
                   (lambda (gd) (file-relative-name (file-name-directory gd) (expand-file-name "~")))
                   (split-string (shell-command-to-string "find ~/src -maxdepth 4 -name .git -type d") "\n" t))
                  `(".emacs.d"))))
        (ivy-add-actions ps (lambda (p) (with-ivy-window
                                          (magit-status (expand-file-name p "~")))))))

    (defun ivy-jump-to-project ()
      (interactive)
      (ivy-read
       "jump to project "
       (ivy-jump-to-project-candidates)
       :action (lambda (c) (funcall (get-ivy-action c) c))))
  #+end_src
