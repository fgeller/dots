#+TITLE: Emacs Initialization
#+STARTUP: hideblocks
* Notes

Don't forget to =git submodules init= and =git submodules update=.

Load this file with the following incantation (e.g., in =~/.emacs=):

#+begin_src emacs-lisp :tangle no
(org-babel-load-file (expand-file-name "~/.emacs.d/init.org"))
#+end_src

Main sources are @purcell's emacs.d [11] and the Emacswiki [12].

* Environment
** Editor

	 Set default editor in (e)shell to emacsclient.
#+begin_src emacs-lisp
(setenv "EDITOR" "emacsclient")
#+end_src

** Load path

The load path is augmented by =~/.emacs.d/site-lisp= and all direct
children folders.

#+begin_src emacs-lisp
(dolist (addition '("~/.emacs.d/site-lisp"))
	(add-to-list 'load-path addition)
	(let ((default-directory addition))
		(normal-top-level-add-subdirs-to-load-path)))
#+end_src

** Exec path
Helper from @purcell to fix the PATH and `exec-path' based an
default shell's settings. Execute it immediately.
#+begin_src emacs-lisp
(defun c/set-exec-path-from-shell-PATH ()
	(let ((path-from-shell
	 (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
		(setenv "PATH" path-from-shell)
		(setq exec-path (split-string path-from-shell path-separator))))
(c/set-exec-path-from-shell-PATH)
#+end_src

* Global helpers
Helper to guess the project root based on code in =full-ack.el=

#+begin_src emacs-lisp
(defvar c/project-root-file-patterns
	'(".project\\'" ".xcodeproj\\'" ".sln\\'" "\\`Project.ede\\'"
		"\\`.git\\'" "\\`.bzr\\'" "\\`_darcs\\'" "\\`.hg\\'"))

(defun c/guess-project-root ()
	(interactive)
	(catch 'root
		(let ((dir (expand-file-name (if buffer-file-name
						 (file-name-directory buffer-file-name)
					 default-directory)))
		(prev-dir nil)
		(pattern (mapconcat 'identity c/project-root-file-patterns "\\|")))
			(while (not (equal dir prev-dir))
	(when (directory-files dir nil pattern t)
		(throw 'root dir))
	(setq prev-dir dir
				dir (file-name-directory (directory-file-name dir)))))))
#+end_src

Look backward for a regex  and return group 1.

#+begin_src emacs-lisp
(defun c/find-backward (re-pattern)
	"Look backward for a regex  and return group 1."
	(save-excursion
		(re-search-backward re-pattern)
		(match-string 1)))
#+end_src

* Loading libraries
** Globally desirable included libraries
We load a set of libraries that are generally desirable.

#+begin_src emacs-lisp
(require 'cl)
(require 'package)
(require 'repeat)
(require 'uniquify)
(require 'grep)
(require 'thingatpt)
#+end_src

** ELPA

Helper from @purcell to load elpa packages.

#+begin_src emacs-lisp
(defun c/require-package (package &optional min-version no-refresh)
	"Ask elpa to install given PACKAGE."
	(if (package-installed-p package min-version)
			t
		(if (or (assoc package package-archive-contents) no-refresh)
	(package-install package)
			(progn
	(package-refresh-contents)
	(require-package package min-version t)))))
#+end_src

Configure ELPA package handling.

#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
(add-to-list 'package-archives '("elpa" . "http://tromey.com/elpa/"))
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
(package-initialize)
#+end_src

Load additional packages from ELPA archives.

#+begin_src emacs-lisp
(setq c/elpa-packages '(
	pretty-symbols-mode
	session
	dired+
	dired-details
	dired-details+
	helm
	flymake-cursor
	expand-region
	mark-multiple
	yasnippet
	magit
	js2-mode
	python    ;; @fgallina's python's flying circus support for Emacs.
	org
	pointback
	move-text
	mic-paren
	wgrep
	todochiku
	gtags
))
(dolist (package c/elpa-packages)
		(c/require-package package))
#+end_src

** Globally desirable external libraries

We use key-chord to have homerow access to the most common used
bindings via a custom map.

#+begin_src emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
(setq key-chord-two-keys-delay 0.15)
#+end_src

Helm is used for most completion and especially file/buffer
navigation. Need in on form the start.

#+begin_src emacs-lisp
(require 'helm-config)
(helm-mode 1)
#+end_src

Allows for selecting in semantic units. Interesting mostly for
=prog-modes=, but needs to be =required=, so function definition is
available for make-repeatable-command

#+begin_src emacs-lisp
(require 'expand-region)
#+end_src

Move lines up and down with =meta= and cursor keys.

#+begin_src emacs-lisp
(require 'move-text)
(move-text-default-bindings)
#+end_src

Helpers to do rectangle insert inline and mark multiple occurences of
active region.

#+begin_src emacs-lisp
(autoload 'inline-string-rectangle "inline-string-rectangle" t nil)
(autoload 'mark-previous-like-this "mark-more-like-this" t nil)
(autoload 'mark-next-like-this "mark-more-like-this" t nil)
#+end_src

Email. With tags. Org-mode support for direct mail links. Yay.

#+begin_src emacs-lisp
(autoload 'notmuch "notmuch" t nil)
(eval-after-load 'notmuch
	'(progn
		 (require 'org-notmuch)))
#+end_src

Growl notifications.

#+begin_src emacs-lisp
(setq todochiku-icons-directory (expand-file-name "~/.emacs.d/src/todochiku-icons/"))
(autoload 'todochiku-message "todochiku" t nil)
#+end_src

@gigamonkey's jumper mode.

#+begin_src emacs-lisp
(autoload 'jumper-mode "jumper" t nil)
(autoload 'jumper-update-defs-from-current-buffer "jumper-update" t nil)
#+end_src

* Text editing
** Helper

Duplicate the current line, below point.

#+begin_src emacs-lisp
(defun c/duplicate-line ()
	(interactive)
	(save-excursion
		(let ((line-text (buffer-substring-no-properties
					(line-beginning-position)
					(line-end-position))))
			(move-end-of-line 1)
			(newline)
			(insert line-text))))
#+end_src

Change the number at point incrementally.

#+begin_src emacs-lisp
(defun c/change-num-at-point (fn)
	(let* ((num (string-to-number (thing-at-point 'word)))
	 (bounds (bounds-of-thing-at-point 'word)))
		(save-excursion
			(goto-char (car bounds))
			(kill-word 1)
			(insert (number-to-string (funcall fn num 1))))))

(defun c/inc-num-at-point ()
	(interactive)
	(c/change-num-at-point '+))

(defun c/dec-num-at-point ()
	(interactive)
	(c/change-num-at-point '-))
#+end_src

Goto the matching paren of when point is looking at one.

#+begin_src emacs-lisp
(defun c/goto-match-paren (arg)
	"Go to the matching parenthesis if on parenthesis, otherwise insert
the character typed."
	(interactive "p")
	(cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
	((looking-at "\\s\)") (forward-char 1) (backward-list 1))
	(t                    (self-insert-command (or arg 1))) ))
#+end_src

** Settings

Don't use tabs by default. Override this in =.dir-locals.el=.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

Allow repeated popping of mark.

#+begin_src emacs-lisp
(setq set-mark-command-repeat-pop t)
#+end_src

Enable electric indenting.

#+begin_src emacs-lisp
(electric-indent-mode 1)
#+end_src

Enabling electric pairing.

#+begin_src emacs-lisp
(electric-pair-mode 1)
#+end_src

Use the system's default browser.

#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+end_src

Global whitespace settings. Override them in =.dir-local.el= or file
variables.

#+begin_src emacs-lisp
  (setq
   whitespace-style
			  '(
				  face
				  tabs
				  spaces
				  trailing
				  lines
				  space-before-tab
				  newline
				  indentation::space
				  empty ; remove all empty lines at beginning/end of buffer
				  space-after-tab
				  space-mark
				  tab-mark
				  newline-mark
				  ))
#+end_src

Don't disable narrowing.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'narrow-to-defun 'disabled nil)
#+end_src

Show matching parentheses.

#+begin_src emacs-lisp
(show-paren-mode 1)
(setq show-paren-style 'expression)
#+end_src

Restore the correct point in windows / buffers.

#+begin_src emacs-lisp
(global-pointback-mode 1)
#+end_src

Replace active region, rather than appending to it.

#+begin_src emacs-lisp
(delete-selection-mode 1)
#+end_src

** Yasnippet

#+begin_src  emacs-lisp
(require 'yasnippet)
(add-to-list 'yas/snippet-dirs (expand-file-name "~/.emacs.d/snippets"))
(yas/global-mode 1)
#+end_src

** isearch

Zap (active region) while searching via isearch [4].

#+begin_src  emacs-lisp
(defun zap-to-isearch (rbeg rend)
	"Kill the region between the mark and the closest portion of
the isearch match string. The behaviour is meant to be analogous
to zap-to-char; let's call it zap-to-isearch. The deleted region
does not include the isearch word. This is meant to be bound only
in isearch mode.  The point of this function is that oftentimes
you want to delete some portion of text, one end of which happens
to be an active isearch word. The observation to make is that if
you use isearch a lot to move the cursor around (as you should,
it is much more efficient than using the arrows), it happens a
lot that you could just delete the active region between the mark
and the point, not include the isearch word."
	(interactive "r")
	(when (not mark-active)
		(error "Mark is not active"))
	(let* ((isearch-bounds (list isearch-other-end (point)))
	 (ismin (apply 'min isearch-bounds))
	 (ismax (apply 'max isearch-bounds))
	 )
		(if (< (mark) ismin)
	(kill-region (mark) ismin)
			(if (> (mark) ismax)
		(kill-region ismax (mark))
	(error "Internal error in isearch kill function.")))
		(isearch-exit)
		))
#+end_src

Exit isearch, but at the other end of the match [5]. For example:

#+BEGIN_QUOTE
Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam
nonummy nibh euismod tincidunt ut [laoreet] dolore magna aliquam erat
volutpat.
#+END_QUOTE

Searching for =laoreet= and hitting =C-RET= will leave point at =[= while
hitting =RET= will leave point at =]=.

#+begin_src emacs-lisp
(defun isearch-exit-other-end (rbeg rend)
	"Exit isearch, but at the other end of the search string.
This is useful when followed by an immediate kill."
	(interactive "r")
	(isearch-exit)
	(goto-char isearch-other-end))
#+end_src

Yank current symbol as regex, rather than word (=C-w=) [6].

#+begin_src emacs-lisp
(defun isearch-yank-regexp (regexp)
	"Pull REGEXP into search regexp."
	(let ((isearch-regexp nil)) ;; Dynamic binding of global.
		(isearch-yank-string regexp))
	(if (not isearch-regexp)
			(isearch-toggle-regexp))
	(isearch-search-and-update))
(defun isearch-yank-symbol ()
	"Put symbol at current point into search string."
	(interactive)
	(let ((sym (find-tag-default)))
		(message "sym: %s" sym)
		(if (null sym)
	(message "No symbol at point")
			(isearch-yank-regexp
			 (concat "\\_<" (regexp-quote sym) "\\_>")))))
#+end_src
** grep

Ignore virtualenv folders (typically named =env=)

#+begin_src emacs-lisp
(add-to-list 'grep-find-ignored-directories "env")
#+end_src

Use GNU find an Mac OS (via homebrew)

#+begin_src emacs-lisp
(setq-default find-program "gfind")
(grep-apply-setting 'grep-find-command "gfind . -type f -exec grep -nH -e  {} +")
(grep-apply-setting 'grep-find-template "gfind . <X> -type f <F> -exec grep <C> -nH -e <R> {} +")
#+end_src

Wrapper to =rgrep= to set =default-directory= to the (guessed) project root.

#+begin_src emacs-lisp
(defun c/rgrep-from-project-root ()
	(interactive)
	(let ((default-directory (c/guess-project-root)))
		(call-interactively 'rgrep)))
#+end_src

Appearance of the results buffer.

#+begin_src emacs-lisp
(setq
 grep-highlight-matches t
 grep-scroll-output t
)
#+end_src

** ispell

Use aspell on Mac OS.

#+begin_src emacs-lisp
(when (executable-find "aspell")
	(setq ispell-program-name "aspell"
	ispell-extra-args '("--sug-mode=ultra")))
#+end_src

** ediff

 Split the diff windows horizontally, rather than vertically.

#+begin_src emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally)
#+end_src

Don't use multiple frames. One is confusing enough.

#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

* Programming

Show trailing whitespace when editing source code.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook (lambda () (setq show-trailing-whitespace t)))
#+end_src

** Compiling

Settings for compilation mode.

#+begin_src emacs-lisp
(setq
 compilation-scroll-output t
 compilation-message-face nil  ;; don't underline
)
#+end_src

** Flymake
#+begin_src emacs-lisp
	(eval-after-load 'flymake
		'(progn
			 (require 'flymake-cursor)
			 ;; don't want this on Mac OS X -- http://koansys.com/tech/emacs-hangs-on-flymake-under-os-x
			 (setq flymake-gui-warnings-enabled nil)
			 (setq flymake-start-syntax-check-on-newline t)
			 (setq flymake-compilation-prevents-syntax-check nil)
			 (setq flymake-run-in-place nil)  ;; I want my copies in the system temp dir.
	))
#+end_src
** Javascript

Use =js2-mode= for editing Javascript.

#+begin_src emacs-lisp
(autoload 'js2-mode "js2-mode" t nil)
(add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src

Buffer-specific configuration.

#+begin_src emacs-lisp
	(defun c/js2-mode-initialization ()
		(subword-mode 1)
		(add-hook 'before-save-hook 'whitespace-cleanup nil 'local)
		(setq js2-use-font-lock-faces t)
		(setq js2-mode-must-byte-compile nil)
		(setq js2-basic-offset 2)
		(setq js2-indent-on-enter-key t)
		(setq js2-auto-indent-p t)
		(setq js2-enter-indents-newline t)
		(setq js2-bounce-indent-p nil)
		(setq js2-auto-insert-catch-block t)
		(setq js2-cleanup-whitespace t)
		(setq js2-global-externs '(Ext console))
		(setq js2-highlight-level 3)
		(setq js2-mirror-mode t) ; conflicts with autopair
		(setq js2-mode-escape-quotes t) ; t disables
		(setq js2-mode-squeeze-spaces t)
		(setq js2-pretty-multiline-decl-indentation-p t)
		(setq js2-consistent-level-indent-inner-bracket-p t)
		(setq
		 tab-width 2
		 js2-basic-offset 2
		 indent-tabs-mode t
		 whitespace-style '(face tabs spaces trailing lines space-before-tab::tab newline indentation::tab empty space-after-tab::tab space-mark tab-mark newline-mark)
		 ))

	(eval-after-load 'js2-mode
		'(progn
			 (add-hook 'js2-mode-hook 'c/js2-mode-initialization)))
#+end_src

** Lisp

Configuration per-buffer.

#+begin_src emacs-lisp
(defun c/emacs-lisp-mode-initialization ()
	(pretty-symbols-mode 1)
	(add-hook 'before-save-hook 'whitespace-cleanup nil 'local))
(add-hook 'emacs-lisp-mode-hook 'c/emacs-lisp-mode-initialization)
#+end_src

** Python

Basic system-wide configuration for @fgallina's flying circus. Taken
right from the libraries documentation header.

#+begin_src emacs-lisp
(eval-after-load "python"
	'(progn
		 (setq python-shell-interpreter "ipython"
		 python-shell-interpreter-args ""
		 python-shell-prompt-regexp "In \\[[0-9]+\\]: "
		 python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
		 python-shell-completion-setup-code
		 "from IPython.core.completerlib import module_completion"
		 python-shell-completion-module-string-code
		 "';'.join(module_completion('''%s'''))\n"
		 python-shell-completion-string-code
		 "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
	))
#+end_src

Special configuration for flymake

#+begin_src emacs-lisp
	(defun c/flymake-python-init ()
		(let* ((temp-file (flymake-init-create-temp-buffer-copy
					 'flymake-create-temp-intemp))
		 (local-file (file-relative-name
			temp-file
			(file-name-directory buffer-file-name))))
			(list "pycheckers"  (list local-file))))
	(eval-after-load 'flymake
		'(progn
			 (add-to-list 'flymake-allowed-file-name-masks
			(list "\\.py\\'" 'c/flymake-python-init))))
#+end_src

Configuration per-buffer.

#+begin_src emacs-lisp
  (defun c/python-mode-initialization ()
    (subword-mode 1)
    (jumper-mode 1)
    (pretty-symbols-mode 1)
    (when buffer-file-name (flymake-mode 1))
    (add-hook 'before-save-hook 'whitespace-cleanup nil 'local)
    (add-hook 'before-save-hook 'jumper-update-defs-from-current-buffer nil 'local)
    )
  (add-hook 'python-mode-hook 'c/python-mode-initialization)
#+end_src

*** Helper

Run an individual test, by passing a restrictive predicate to
nosetest. Searches from =point= backward to find test method and
surrounding class name.

#+begin_src emacs-lisp
	(defun c/run-python-test ()
	 (interactive)
	 (let* ((file-name buffer-file-name)
		(project-root (c/guess-project-root))
		(class-name (c/find-backward "class \\(.+\\)("))
		(fun-name (c/find-backward "def \\(test.+\\)("))
		(cmd (format
		"cd %s && TESTSEL=%s:%s.%s make tests"
		project-root
		file-name
		class-name
		fun-name)))
		 (let ((compilation-buffer-name-function (lambda (x) "*tests*")))
			(compile cmd t))))
#+end_src

** SQL

Send the terminator automatically

#+begin_src emacs-lisp
(eval-after-load 'sql
	'(setq sql-send-terminator t))
#+end_src

* Key Bindings
** Helpers
Helper [3] to make any command repeatable analogously to =C-x e e e=
#+begin_src emacs-lisp
(defun make-repeatable-command (cmd)
	"Returns a new command that is a repeatable version of CMD.
The new command is named CMD-repeat.  CMD should be a quoted
command.

This allows you to bind the command to a compound keystroke and
repeat it with just the final key.  For example:

	(global-set-key (kbd \"C-c a\") (make-repeatable-command 'foo))

will create a new command called foo-repeat.  Typing C-c a will
just invoke foo.  Typing C-c a a a will invoke foo three times,
and so on."
	(fset (intern (concat (symbol-name cmd) "-repeat"))
	`(lambda ,(help-function-arglist cmd) ;; arg list
		 ,(format "A repeatable version of `%s'." (symbol-name cmd)) ;; doc string
		 ,(interactive-form cmd) ;; interactive form
		 ;; see also repeat-message-function
		 (setq last-repeatable-command ',cmd)
		 (repeat nil)))
	(intern (concat (symbol-name cmd) "-repeat")))
#+end_src
** Custom prefix map

	 Define custom map that can be used to accumulate any number of
	 custom bindings. Should be easy to access, therefore we use uh
	 (both on home row on Dvorak layout)
#+begin_src emacs-lisp
	(defvar c/map (make-keymap)
		"Keymap for custom local bindings and functions")
	(key-chord-define-global ",." 'c/map-prefix)
	(fset 'c/map-prefix c/map)
#+end_src

*** Various tools
#+begin_src emacs-lisp
(define-key c/map "g" 'c/rgrep-from-project-root)
(define-key c/map "n" 'notmuch)
(define-key c/map "ss" 'eshell)
(define-key c/map "sn" 'c/eshell-with-prefix)
(define-key c/map "U" 'browse-url-default-macosx-browser)
#+end_src
*** Enable / disable modes
#+begin_src emacs-lisp
(define-key c/map "mr" 'auto-revert-mode)
(define-key c/map "mw" 'whitespace-mode)
#+end_src

** Dvorak
Swap =C-t= and =C-x=, so it's easier to type on Dvorak layout
#+begin_src emacs-lisp
(keyboard-translate ?\C-t ?\C-x)
(keyboard-translate ?\C-x ?\C-t)
#+end_src
** C-x Map
#+begin_src emacs-lisp
(define-key ctl-x-map "^" (make-repeatable-command 'enlarge-window))
(define-key ctl-x-map "}" (make-repeatable-command 'enlarge-window-horizontally))
(define-key ctl-x-map "{" (make-repeatable-command 'shrink-window-horizontally))
(define-key ctl-x-map "o" (make-repeatable-command 'other-window))
#+end_src
** Mac OS
#+begin_src emacs-lisp
(setq mac-command-modifier 'super)
(setq mac-option-modifier 'meta)
(setq default-input-method "MacOSX")
(global-set-key (kbd "S-`") 'ns-next-frame)
(global-set-key (kbd "S-h") 'ns-do-hide-others)
;(setq mouse-wheel-scroll-amount '(0.0001))
#+end_src
** Dired

Use Mac OS' open to view files outside of Emacs.

#+begin_src emacs-lisp
(define-key dired-mode-map "o" 'c/dired-open-mac)
#+end_src

** Magit

#+begin_src emacs-lisp
(eval-after-load 'magit
	'(define-key magit-status-mode-map (kbd "C-!") 'c/magit-full-push))
#+end_src

** Email
#+begin_src emacs-lisp
	(eval-after-load 'message
	'(define-key message-mode-map (kbd "C-c C-b") 'c/goto-message-body))
	(eval-after-load 'notmuch
	'(progn
	(define-key notmuch-search-mode-map (kbd "Q") 'c/notmuch-archive-all-and-quit)
	(define-key notmuch-search-mode-map (kbd "a") 'c/notmuch-archive)
	(define-key notmuch-search-mode-map (kbd "g") 'notmuch-search-refresh-view)
	(define-key notmuch-hello-mode-map "g" 'notmuch-hello-update)))
#+end_src
** Helm
Add help specific bindings, the =a= is a residue from helm's previous
name "anything".
#+begin_src emacs-lisp
(define-key c/map "aa"		'c/helm-jump)
(define-key c/map "ab"		'helm-browse-code)
(define-key c/map "ac"		'c/helm-contact)
(define-key c/map "ad"		'helm-c-apropos)
(define-key c/map "af"		'helm-find-files)
(define-key c/map "ag"		'c/helm-do-rgrep)
(define-key c/map "al"		'helm-locate)
(define-key c/map "ar"		'helm-regexp)
(define-key c/map "au"		'helm-ucs)
(define-key c/map "ay"		'helm-show-kill-ring)
(define-key c/map "ax"		'helm-M-x)
#+end_src
** Evaluation
#+begin_src emacs-lisp
(define-key c/map "xx"		'execute-extended-command)
(define-key c/map "xb"		'eval-buffer)
(define-key c/map "xe"		'eval-last-sexp)
(define-key c/map "xr"		'eval-region)
#+end_src
** Input method

Fast switch to German postfix input method.

#+begin_src emacs-lisp
(defun c/set-german-postfix-input-method () (interactive) (set-input-method 'german-postfix))
(define-key c/map "id" 'c/set-german-postfix-input-method)
#+end_src

** Info
#+begin_src emacs-lisp
(global-set-key (kbd "C-h t") 'describe-face)
#+end_src
** Buffers
#+begin_src emacs-lisp
(define-key c/map "br" 'rename-buffer)
(define-key c/map "bR" 'revert-buffer)
#+end_src
** Motion
Source [13]

#+begin_src emacs-lisp
(defvar c/scroll-half-window-was-up nil "Was the last half-scrolling going up?")
(defun c/scroll-half-window ()
		"By default, attention go forward by half a window as follows:
		If point is in upper half of window, then point jumps to lower half.
		(current line will change)
		If point is in lower half, the scroll up to make point in upper half.
		(current line will not change)

		But if the last command is a member of `up-command-list', then reverse.

		Consecutive invocation maintains in the same travel direction.
		Works especially well with modes that highlight the current line.

		The actual destinations of the point are controlled by `upper-precent' and
		`lower-percent'."
		(interactive)
		(let* ( ;;manually set these personal preferences
		 (upper-percent 0.15)
		 (lower-percent 0.85)
		 (up-command-list '(previous-line
						scroll-down
						pager-page-up))
		 ;; number of lines shown in selected window, one less due to mode line
		 (winlines (1- (window-height (selected-window))))
		 ;; number of lines above and below point
		 (above (+ (count-lines (window-start) (point))
				 -1 (if (= (current-column) 0) 1 0)))
		 (below (- winlines above 1)))
			;; compute if we should go up or not
			(let ((should-up (or (and c/scroll-half-window-was-up
				(eq last-command 'c/scroll-half-window))
				 (memq last-command up-command-list))))
	;; dispatch depending on whether point is in upper half or lower half
	(if (< above below)
		(apply (if should-up 'scroll-down 'forward-line) ;upper
		 (list (- (floor (* winlines lower-percent)) above)))
		(apply (if should-up 'forward-line 'scroll-down) ;lower
		 (list (- (floor (* winlines upper-percent)) above))))
	;; done, remember last direction before exit
	(setq c/scroll-half-window-was-up should-up))))
#+end_src

Bind the scrolling for easy access

#+begin_src emacs-lisp
(global-set-key (kbd "s-SPC") (make-repeatable-command 'c/scroll-half-window))
#+end_src

Fast jumping to matching paren.

#+begin_src emacs-lisp
(define-key c/map "%" (make-repeatable-command 'c/goto-match-paren))
#+end_src

No =Meta= for jumping to the beginning/end of the buffer.

#+begin_src emacs-lisp
(define-key c/map "<" 'beginning-of-buffer)
(define-key c/map ">" 'end-of-buffer)
#+end_src

isearch-specific bindings to use symbol at point and exit search on
the "other end" of the match.

#+begin_src emacs-lisp
(define-key isearch-mode-map (kbd "M-w") 'isearch-yank-symbol)
(define-key isearch-mode-map [(control return)] 'isearch-exit-other-end)
#+end_src

** Source code editing
#+begin_src emacs-lisp
(define-key c/map "caa"		'align)
(define-key c/map "car"		'align-regexp)
(define-key c/map "cr"		'recompile)
(define-key c/map "cc"		'compile)
(global-set-key (kbd "C-<") 'mark-previous-like-this)
(global-set-key (kbd "C->") 'mark-next-like-this)
(global-set-key (kbd "C-c w") (make-repeatable-command 'er/expand-region))
#+end_src
** General text editing
#+begin_src emacs-lisp
(define-key c/map "+" (make-repeatable-command 'c/inc-num-at-point))
(define-key c/map "-" (make-repeatable-command 'c/dec-num-at-point))
(define-key c/map "ld" (make-repeatable-command 'c/duplicate-line))
(define-key c/map "ll" 'goto-line)
(define-key c/map "q" 'query-replace)
(define-key c/map "Q" 'query-replace-regexp)
(define-key c/map "^" (make-repeatable-command 'join-line))
(global-set-key (kbd "C-x r t") 'inline-string-rectangle)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
(define-key isearch-mode-map (kbd "M-z") 'zap-to-isearch)
#+end_src
** Org mode
#+begin_src emacs-lisp
	(define-key c/map "of" 'org-footnote-action)
	(define-key global-map (kbd "C-c l") 'org-store-link)
	(define-key global-map (kbd "C-c a") 'org-agenda)
	(define-key global-map (kbd "C-c c") 'org-capture)
	(eval-after-load 'org-agenda
		'(define-key org-agenda-mode-map (kbd "C-c t") 'org-agenda-todo))
	(eval-after-load 'org
		'(define-key org-mode-map (kbd "C-c t") 'org-todo))
#+end_src
** Version control
#+begin_src emacs-lisp
(define-key c/map "v="		'vc-diff)
(define-key c/map "vd"		'vc-dir)
(define-key c/map "vD"		'vc-delete-file)
(define-key c/map "vF"		'vc-pull)
(define-key c/map "vg"		'vc-annotate)
(define-key c/map "vl"		'vc-print-log)
(define-key c/map "vu"		'vc-revert)
(define-key c/map "vv"		'vc-next-action)
(define-key c/map "vm"		'magit-status)
#+end_src
** Programming modes
*** JS2 mode

#+begin_src emacs-lisp
(eval-after-load 'js2-mode
	'(progn
		 (define-key js2-mode-map (kbd "C-c !") (make-repeatable-command 'js2-next-error))
		 ))
#+end_src

*** Python mode

#+begin_src emacs-lisp
	(eval-after-load 'python
		'(progn
			 (define-key python-mode-map (kbd "C-c t") 'c/run-python-test)
			 (define-key python-mode-map (kbd "C-c b") 'python-insert-breakpoint)
			 (define-key python-mode-map (kbd "RET") 'newline-and-indent)
			 (eval-after-load 'flymake
	 '(progn
			(define-key python-mode-map (kbd "C-c !") (make-repeatable-command 'flymake-goto-next-error))))
			 ))
#+end_src

* Appearance
** General GUI Settings
Less noisy Emacs startup and less noise on screen per default.
 #+begin_src emacs-lisp
(setq
 blink-cursor-delay 0
 blink-cursor-interval 0.5
	use-file-dialog nil
	use-dialog-box nil
	inhibit-startup-screen t
	inhibit-startup-echo-area-message t
	truncate-lines t
	truncate-partial-width-windows nil
	visible-bell nil
	transient-mark-mode t   ;; highlight the active region when mark is active
	show-trailing-whitespace nil ;; don't show trailing whitespace globally
	blink-matching-paren t
	;;line-spacing 0.2
	;;column-number-mode t
	;;size-indication-mode t
	;;mouse-yank-at-point t
)
(tool-bar-mode -1)
(set-scroll-bar-mode nil)
(setq default-frame-alist '((left-fringe . 0) (right-fringe . 0)))
 #+end_src

Highlight URLs and email addresses.

#+begin_src emacs-lisp
;;(setq goto-address-mail-face 'link)
(add-hook 'find-file-hooks 'goto-address-prog-mode)
#+end_src

y and n  are sufficient.

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Fonts

Set default fonts across frames to Calibri.

#+begin_src emacs-lisp
(setq c/variable-width-font-family "Calibri")
(setq c/variable-width-font-height 180)
(setq c/mono-space-font-family "Consolas")
(setq c/mono-space-font-height 170)
(set-face-attribute 'default nil
	:family c/variable-width-font-family :height c/variable-width-font-height :weight 'normal)
#+end_src

Define some helpers to switch between variable-width and mono-spaced
fonts per buffer.

#+begin_src emacs-lisp
(defun c/set-variable-width-font ()
	(interactive)
	(variable-pitch-mode t)
	(set-face-attribute 'variable-pitch nil
					:family c/variable-width-font-family :height c/variable-width-font-height :weight 'normal))

(defun c/set-mono-space-font ()
	(interactive)
	(variable-pitch-mode t)
	(set-face-attribute 'variable-pitch nil
					:family c/mono-space-font-family :height c/mono-space-font-height :weight 'normal))
#+end_src

Use monospace for some modes.

#+begin_src emacs-lisp
(add-hook 'calendar-mode-hook 'c/set-mono-space-font)
(add-hook 'notmuch-hello-mode-hook 'c/set-mono-space-font)
(add-hook 'notmuch-search-hook 'c/set-mono-space-font)
(add-hook 'term-mode-hook 'c/set-mono-space-font)
#+end_src

** Theme

Load the solarized theme implementation by @purcell.
#+begin_src emacs-lisp
(require 'color-theme-sanityinc-solarized)
#+end_src

** Mode-line
Less noise in the mode-line. Based on several sources [2]
#+begin_src emacs-lisp
	(defun c/mode-line-js2-errors ()
	(interactive)
		(when (string= "JavaScript-IDE" mode-name)
			(let* (
				 (errs (copy-sequence (js2-ast-root-errors js2-mode-ast)))
				 (warns (copy-sequence (js2-ast-root-warnings js2-mode-ast)))
				 (errs-length (safe-length errs))
				 (warns-length (safe-length warns)))
		(when (or (< 0 errs-length) (< 0 warns-length))
			(concat
			 " τ:"
			 (propertize (number-to-string errs-length) 'face 'flymake-errline)
			 ","
			 (propertize (number-to-string warns-length) 'face 'flymake-warnline))))))
	(defun c/mode-line-flymake ()
		(when (and
			 (boundp 'flymake-mode-line-e-w)
			 flymake-mode-line-e-w
			 (not (string= "" flymake-mode-line-e-w))
			 (not (string= "0/0" flymake-mode-line-e-w)))
			(progn
		(string-match "\\([0-9]+\\)/\\([0-9]+\\)" flymake-mode-line-e-w)
		(let ((error-str (match-string 1 flymake-mode-line-e-w))
		(warn-str (match-string 2 flymake-mode-line-e-w)))
			(concat " τ:" (propertize error-str 'face 'flymake-errline) "," (propertize warn-str 'face 'flymake-warnline))))))
	(defun c/mode-line-compilation ()
		(cond
		 ((string= ":exit [2]" mode-line-process) (propertize " x" 'face 'error))
		 ((string= ":exit [0]" mode-line-process) " ✓")
		 (t mode-line-process)))
	(setq-default
	 mode-line-format
	 (list
		" "
		mode-line-mule-info ;; Info about the active input method and coding-system
		mode-line-remote ;; Small indicator for tramp'ed files
		'(:eval (propertize "%b" 'face 'mode-line-buffer-id)) ;; buffer name
		'(:eval (when buffer-read-only (propertize "%" 'face 'mode-line)))
		'(:eval (when (buffer-modified-p) (propertize "*" 'face 'mode-line-highlight)))
		(propertize " %l:%c %p/%I " 'face 'mode-line) ;; line
	;  mode-name
		(list
		 (propertize "%[" 'help-echo "Recursive edit, type C-M-c to get out")
		 `(:propertize ("" mode-name)
			 mouse-face mode-line-highlight
			 local-map ,mode-line-major-mode-keymap)
		 (propertize "%n" 'help-echo "mouse-2: Remove narrowing from the current buffer"
		 'mouse-face 'mode-line-highlight
		 'local-map (make-mode-line-mouse-map
					 'mouse-2 #'mode-line-widen))
		 (propertize "%]" 'help-echo "Recursive edit, type C-M-c to get out")
		 )
		'(:eval (c/mode-line-compilation))
		'(vc-mode vc-mode)
		'(:eval (c/mode-line-flymake))
		'(:eval (c/mode-line-js2-errors))
		""
		mode-line-client
		)
	 )
#+end_src
** Buffer
#+begin_src emacs-lisp
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
(setq uniquify-after-kill-buffer-p t)
(setq uniquify-ignore-buffers-re "^\\*")
#+end_src
* Buffers and sessions
** Settings
Don't remember temporary and tramp'ed files.

#+begin_src emacs-lisp
(setq
 recentf-max-saved-items 300
 recentf-exclude '("/tmp/" "/ssh:" "/sudo:")
)
#+end_src

Don't ask when reverting buffer to buffer-file's contents.

#+begin_src emacs-lisp
(setq revert-without-query '(".*"))
#+end_src

Enable recursive mini-buffers

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src

** Automatic saving and backing up
*** File-visiting buffers
 Turn on automatic saving.

#+begin_src emacs-lisp
(setq auto-save-default t)
#+end_src

 Save everything in a single folder below =~/.emacs.d=.
 Create the folder on the fly, if necessary.

#+begin_src emacs-lisp
(defvar c/saved-directory (expand-file-name "~/.emacs.d/saved/"))
(make-directory c/saved-directory t)
#+end_src

Place autosaves and backups to in a single directory.

#+begin_src emacs-lisp
	(setq backup-directory-alist
	`((".*" . ,c/saved-directory)))
	(setq auto-save-file-name-transforms
	`((".*" ,c/saved-directory t)))
#+end_src

Do not delete old versions silently.

#+begin_src emacs-lisp
(setq delete-old-versions nil)
#+end_src

Don't make backup files when renaming files.

#+begin_src emacs-lisp
(setq make-backup-files nil)
#+end_src

*** scratch buffer

Based on blog post at [10].

Where to store the files for persistence across sessions.

#+begin_src emacs-lisp
(defvar c/persistent-scratch-filename
	(expand-file-name (concat c/saved-directory "emacs-persistent-scratch"))
	"Location of *scratch* file contents for persistent-scratch.")
(defvar c/persistent-scratch-backup-directory
	(expand-file-name (concat c/saved-directory "emacs-persistent-scratch-backups/"))
	"Location of backups of the *scratch* buffer contents for
		persistent-scratch.")
(make-directory c/persistent-scratch-backup-directory t)
#+end_src

Helper to create a file name to store the scratch buffer.

#+begin_src emacs-lisp
(defun c/make-persistent-scratch-backup-name ()
	"Create a filename to backup the current scratch file by
	concatenating C/PERSISTENT-SCRATCH-BACKUP-DIRECTORY with the
	current date and time."
	(concat
	 c/persistent-scratch-backup-directory
	 (replace-regexp-in-string
		(regexp-quote " ") "-" (format-time-string "%d%m%y_%H%M%S"))))
#+end_src

Helper to save the contents of the scratch buffer to a file.

#+begin_src emacs-lisp
(defun c/save-persistent-scratch ()
	"Write the contents of *scratch* to the file name
	C/PERSISTENT-SCRATCH-FILENAME, making a backup copy in
	C/PERSISTENT-SCRATCH-BACKUP-DIRECTORY."
	(with-current-buffer (get-buffer "*scratch*")
		(if (file-exists-p c/persistent-scratch-filename)
	(copy-file c/persistent-scratch-filename
			 (c/make-persistent-scratch-backup-name)))
		(write-region (point-min) (point-max)
			c/persistent-scratch-filename)))

#+end_src

Helper to load the last saved contents of the scratch buffer on startup.

#+begin_src emacs-lisp
(defun c/load-persistent-scratch ()
	"Load the contents of C/PERSISTENT-SCRATCH-FILENAME into the
	scratch buffer, clearing its contents first."
	(if (file-exists-p c/persistent-scratch-filename)
			(with-current-buffer (get-buffer "*scratch*")
	(delete-region (point-min) (point-max))
	(insert-file-contents c/persistent-scratch-filename))))
#+end_src

Hook everything in: Load on startup and save on kill-emacs

#+begin_src emacs-lisp
(c/load-persistent-scratch)
(push #'c/save-persistent-scratch kill-emacs-hook)
#+end_src

* Helm
** Configuration

Don't fill in single matches when selecting files.

#+begin_src emacs-lisp
(setq helm-ff-auto-update-initial-value nil)
#+end_src

Show the full path to files.

#+begin_src emacs-lisp
(setq helm-ff-transformer-show-only-basename nil)
#+end_src

** Sources

Source that searches for files  in current project [8].

#+begin_src emacs-lisp
(defvar c/helm-c-source-project-file-search
	`((name . "Project File Search")
		(init . (lambda ()
				(setq
				 helm-default-directory default-directory
				 project-root-folder (c/guess-project-root))))
		(candidates . (lambda ()
				(start-process-shell-command "file-search-process" nil
						 "gfind" (format "%s -iname '*%s*' -print" project-root-folder helm-pattern))))
		(keymap . ,helm-generic-files-map)
		(mode-line . helm-generic-file-mode-line-string)
		(match helm-c-match-on-basename)
		(type . file)
		(requires-pattern . 4))
	"Source for searching files in current project recursively.")
#+end_src

** Accessors to sources

Collection of sources that we want fast access to.

#+begin_src emacs-lisp
(defun c/helm-jump ()
	(interactive)
	(helm-other-buffer
	 '(
		 helm-c-source-buffers-list
		 helm-c-source-ctags
		 helm-c-source-recentf
		 c/helm-c-source-project-file-search
		 helm-c-source-buffer-not-found
		 )
	 "*c/helm-jump*"))
#+end_src

Wrapper to =helm-do-grep= that sends the prefix argument so we search
for files recursively by default.

#+begin_src emacs-lisp
(defun c/helm-do-rgrep ()
	(interactive)
	(let ((current-prefix-arg '(4)))
		(call-interactively 'helm-do-grep)))
#+end_src

* Eshell

Lots of information at [9].

#+begin_src emacs-lisp
(setq eshell-directory-name "~/.emacs.d/.eshell/")
#+end_src

Helper that is used for key-bindings to call eshell with a prefix to
create a new one.

#+begin_src emacs-lisp
(defun c/eshell-with-prefix ()
	(interactive)
	(setq current-prefix-arg '(4))
	(call-interactively 'eshell))
#+end_src

** Prompt
*** Helpers

Custom prompt function.

#+begin_src emacs-lisp
(defun c/eshell-prompt-function ()
	(concat (c/eshell-git-info) (c/eshell-replace-prompt-prefixes) "/ "))
(setq eshell-prompt-function #'c/eshell-prompt-function)
#+end_src

Tell eshell what the prompt looks like after we change it.

#+begin_src emacs-lisp
(setq eshell-prompt-regexp "^[^\n]*/ ")
#+end_src

Returns the current eshell/pwd with common prefixes (TRAMP, home
directory) replaced.

#+begin_src emacs-lisp
(defun c/eshell-replace-prompt-prefixes ()
	(let ((absolute-path (eshell/pwd)))
		(cond ((string-match (getenv "HOME") absolute-path)
		 (replace-match "~" nil nil absolute-path))
		((string-match "/ssh:\\(.+\\):" absolute-path)
		 (replace-match (concat "@" (match-string 1 absolute-path) " ")  nil nil absolute-path))
		(t
		 absolute-path))))
#+end_src

Returns the current branch name with a leading space, when in a
git-versioned directory.

#+begin_src emacs-lisp
(eval-after-load 'eshell
	'(progn (require 'vc-git)))
(defun c/eshell-git-info ()
	"Returns the current branch name with a leading space, when in a
git-versioned directory."
	(let* ((branch (vc-git-working-revision (eshell/pwd))))
		(if (not (string-equal "" branch)) (concat branch " ") "")))
#+end_src

* Version Control

Use solarized colors for annote-goodness.

#+begin_src emacs-lisp
(setq vc-annotate-background "#fcf4dc")
(setq vc-annotate-very-old-color "#042028")
(setq vc-annotate-color-map
			'((20 . "#a57705")
	(40 . "#bd3612")
	(50 . "#c60007")
	(60 . "#c61b6e")
	(80 . "#5859b7")
	(100 ."#2075c7")
	(120 ."#259185")
	(140 ."#728a05")))
#+end_src

Ignore tramp'ed files for speeeeed [1]

#+begin_src emacs-lisp
(setq vc-ignore-dir-regexp
			(format "\\(%s\\)\\|\\(%s\\)"
				vc-ignore-dir-regexp
				tramp-file-name-regexp
				))
#+end_src

** Magit

#+begin_src emacs-lisp
(autoload 'git-blame-mode "git-blame" "Minor mode for incremental blame for Git." t)
(autoload 'magit-status "magit")
(autoload 'rebase-mode "rebase-mode")
(add-to-list 'auto-mode-alist '("git-rebase-todo" . rebase-mode))
(defun c/magit-log-edit-initialization () (auto-fill-mode 1))
(add-hook 'magit-log-edit-mode-hook 'c/magit-log-edit-initialization)
#+end_src

* TRAMP

I usually stay in Emacs to edit remote files, therefore it is unlikely
that remote files change without TRAMP noticing. Let's speed this
up :)

#+begin_src emacs-lisp
(setq remote-file-name-inhibit-cache nil)
#+end_src

Save temporaries in =~/.emacs.d=, which is easily accessed and backed-up.

#+begin_src emacs-lisp
(setq tramp-auto-save-directory "~/.emacs.d/saved/")
#+end_src

* Dired
** Helper

Open a file with Mac OS  open from dired. [7]

#+begin_src emacs-lisp
(defun c/dired-open-mac ()
	(interactive)
	(let ((file-name (dired-get-file-for-visit)))
		(if (file-exists-p file-name)
	(call-process "/usr/bin/open" nil 0 nil file-name))))
#+end_src

** Configuration

Allow recursive operations, ask once for top-level directory.

#+begin_src emacs-lisp
(setq dired-recursive-deletes 'top)
#+end_src

Load extensions to dired from dired+.

#+begin_src emacs-lisp
	(eval-after-load 'dired
		'(progn
			 (require 'dired+)
			 (require 'dired-details)
			 (require 'dired-details+)
			 (setq dired-details-hidden-string "")))
#+end_src

* Org

Loads of  configuration settings that need to be split up.

#+begin_src emacs-lisp
	(setq
	 c/org-directory "~/Dropbox/org"
	 org-directory c/org-directory
	 c/work-org-directory "~/Dropbox/work"
	 c/org-task-file (concat c/org-directory "/Tasks.org")
	 c/work-org-task-file (concat c/work-org-directory "/work.org")
	 c/work-org-agenda-files `(,c/work-org-directory)
	 org-log-done t
	 org-completion-use-ido t
	 org-edit-timestamp-down-means-later t
	 org-agenda-start-on-weekday nil
	 org-agenda-ndays 14
	 org-agenda-include-diary t
	 org-agenda-window-setup 'current-window
	 org-agenda-files `(,org-directory)
	 org-fast-tag-selection-single-key 'expert
	 org-tags-column 80
	 org-default-notes-file (concat org-directory "/Notes.org")
	 org-footnote-auto-label (quote plain)
	 org-hide-emphasis-markers t
	 org-hide-leading-stars t
	 org-refile-targets '((org-agenda-files :maxlevel . 5))
	 org-src-fontify-natively t
	 org-agenda-remove-tags t
	 calendar-week-start-day 1
	 org-refile-use-outline-path 'file
	 org-refile-targets  '((nil :maxlevel . 5) (org-agenda-files :maxlevel . 5))
	 org-outline-path-complete-in-steps nil
	 org-todo-keywords '(
					 (sequence "TODO(t)" "STARTED(s)" "|" "DONE(d!/!)")
					 (sequence "WAITING(w@/!)" "SOMEDAY(S)" "PROJECT(P@)" "|" "CANCELLED(c@/!)"))
	 org-clock-persistence-insinuate t
	 org-clock-persist t
	 org-clock-in-resume t
	 org-clock-in-switch-to-state "STARTED"
	 org-clock-into-drawer t
	 org-clock-out-remove-zero-time-clocks t
	 org-modules '(org-habit org-notmuch org-checklist org-eshell org-crypt org-info org-irc org-contacts)
	 org-habit-preceding-days 14
	 org-habit-show-habits-only-for-today t
	 org-habit-completed-glyph ?.
	 org-habit-today-glyph ?o
	 org-special-ctrl-k t
	 org-special-ctrl-a t
	 org-irc-link-to-logs t
	)
	(add-hook 'org-mode-hook 'turn-on-auto-fill)
#+end_src

Load and configure org-contacts.

#+begin_src emacs-lisp
(setq org-contacts-files (list (format "%s/contacts.org" org-directory)))

(eval-after-load 'message
	'(progn
		 (require 'org-contacts)))
#+end_src

Make org-mode and yasnippet cooperate. more.

#+begin_src emacs-lisp
	(defun yas/org-very-safe-expand ()
		(let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

	(add-hook 'org-mode-hook
		 (lambda ()
			 (make-variable-buffer-local 'yas/trigger-key)
			 (setq yas/trigger-key [tab])
			 (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
			 (define-key yas/keymap [tab] 'yas/next-field)))
#+end_src

Cleanup whitespace in org-mode buffers.

#+begin_src emacs-lisp
(defun c/org-mode-per-buffer-customization ()
		(add-hook 'before-save-hook 'whitespace-cleanup nil 'local))

(add-hook 'org-mode-hook 'c/org-mode-per-buffer-customization)
#+end_src

Define additional capture templates.

#+begin_src emacs-lisp
(setq org-capture-templates
			`(("t" "Task"
	 entry (file+headline ,c/org-task-file "Tasks")
	 "* TODO %?\n  SCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"\"))\n\n  %a\n  %i\n")
	("w" "Work task"
	 entry (file+headline ,c/work-org-task-file "Tasks")
	 "* TODO %?\n  SCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"\"))\n\n  %a\n  %i\n")
	("c" "Contacts" entry (file "~/Org/contacts.org")
	 "* %(org-contacts-template-name)
			:PROPERTIES:
			:EMAIL: %(org-contacts-template-email)
			:END:")))
#+end_src

Define additional commands for agenda views.

#+begin_src emacs-lisp
;; agenda
(setq org-agenda-custom-commands
			`(("d" . "Completed / archived items")
	("dt" "[t]oday"
	 tags "ARCHIVE_TIME>=\"<today>\""
	 ((org-agenda-archives-mode t)))
	("dy" "[y]esterday"
	 tags "ARCHIVE_TIME>=\"<-1d>\"&ARCHIVE_TIME<\"<today>\""
	 ((org-agenda-archives-mode t)))
	("dw" "[w]eek"
	 tags "ARCHIVE_TIME>=\"<-1w>\""
	 ((org-agenda-archives-mode t)))
	("I" "Import diary from iCal" agenda ""
	 ((org-agenda-mode-hook
		 (lambda ()
			 (org-mac-iCal)))))
	("w" "Show work related tasks only" agenda ""
	 ((org-agenda-files ',c/work-org-agenda-files)))))
#+end_src

* Notifications
** growl

No default message when compilation is finished.

#+begin_src emacs-lisp
(setq todochiku-compile-message nil)
#+end_src

Add custom notification.

#+begin_src emacs-lisp
(defun c/notify-finished-compilation (buf msg)
	(todochiku-message (format "Compilation in %s:" buf)
				 msg
				 (todochiku-icon 'emacs)))
(add-hook 'compilation-finish-functions 'c/notify-finished-compilation)
#+end_src

* Email
** Mailcap

#+begin_src emacs-lisp
;; use open for PDFs (rather than gv) and images (rather than display)
(setcdr (assoc 'viewer (cdr (assoc "pdf" (assoc "application"  mailcap-mime-data))))
	"open %s")
(setcdr (assoc 'viewer (cdr (assoc ".*" (assoc "image"  mailcap-mime-data))))
	"open %s")
(setcdr (assoc 'test (cdr (assoc ".*" (assoc "image"  mailcap-mime-data))))
	'window-system)
#+end_src

** Notmuch

	 Helper

#+begin_src emacs-lisp
(defun c/notmuch-archive-all-and-quit ()
	(interactive)
	(notmuch-search-tag-all '(("-unread" "-inbox" "-i/inbox")))
	(notmuch-search-quit))

(defun c/notmuch-archive ()
	(interactive)
	(notmuch-search-tag '("-unread" "-inbox" "-i/inbox"))
	(notmuch-search-refresh-view))
#+end_src

Settings

#+begin_src emacs-lisp
	(setq
	 notmuch-fcc-dirs nil
	 notmuch-mua-user-agent-function 'notmuch-mua-user-agent-emacs
	 notmuch-search-oldest-first nil
	 notmuch-show-logo nil
	 notmuch-crypto-process-mime t
	 notmuch-search-line-faces nil
	notmuch-show-all-multipart/alternative-parts nil
	 notmuch-show-insert-text/plain-hook '(
					 notmuch-wash-tidy-citations
					 notmuch-wash-elide-blank-lines
					 notmuch-wash-excerpt-citations
					 notmuch-wash-convert-inline-patch-to-part
					 )
	)
	(eval-after-load 'notmuch
		'(progn
			 (add-hook 'notmuch-show-hook 'notmuch-show-turn-on-visual-line-mode)
			 (add-hook 'notmuch-search-hook 'notmuch-hl-line-mode)))
#+end_src

Saved searches.

#+begin_src emacs-lisp
	(setq notmuch-saved-searches
	'(("i/commits" . "tag:unread  and tag:i/commits and not \"via pb\"")
		("ml/emacs*" . "tag:unread and (tag:ml/emacs-help or tag:ml/emacs-devel)")
		("ml/org" . "tag:unread and (tag:ml/org)")
		("ml/cedet" . "tag:unread and (tag:ml/cedet-devel)")
		("ml/notmuch" . "tag:unread and (tag:ml/notmuch)")
		))
#+end_src

** Message

Helper

#+begin_src emacs-lisp
(defun c/insert-message-sign-pgpmime ()
	(interactive)
	(save-excursion
		(beginning-of-buffer)
		(re-search-forward "--text follows this line--" (point-max) t)
		(end-of-line)
		(newline)
	 (insert "<#secure method=pgpmime mode=sign>")
	 (newline)))

(defun c/goto-message-body ()
	(interactive)
	(message-goto-body)
	(if (re-search-forward "sign>" (point-max) t)
			(newline)))
#+end_src


#+begin_src emacs-lisp
	(eval-after-load 'message
		'(progn
			 (setq
	message-kill-buffer-on-exit t
	message-send-mail-partially-limit nil
	send-mail-function 'sendmail-send-it
	mail-from-style 'angles
	;; http://notmuchmail.org/emacstips/#index12h2
	mail-specify-envelope-from t
	message-sendmail-envelope-from 'header
	mail-envelope-from 'header
	gnus-inhibit-images t
	user-full-name "Felix Geller"
	user-mail-address "fgeller@gmail.com"
	message-signature "Felix Geller"
	)
			 (add-hook 'message-setup-hook 'c/insert-message-sign-pgpmime)
			 (add-hook 'message-mode-hook 'turn-on-auto-fill)
			 ))
#+end_src
* IRC

Who will I be?

#+begin_src emacs-lisp
(setq erc-nick "fg")
#+end_src

Reduce the noise by ignoring status information.

#+begin_src emacs-lisp
(setq erc-hide-list '("JOIN" "PART" "QUIT" "NICK"))
#+end_src

Get growl notifications when receiving private messages.

#+begin_src emacs-lisp
(defun c/notify-privmsg (proc parsed)
	(let ((nick (car (erc-parse-user (erc-response.sender parsed))))
	(target (car (erc-response.command-args parsed)))
	(msg (erc-response.contents parsed)))
		(when (and (erc-current-nick-p target)
				 (not (erc-is-message-ctcp-and-not-action-p msg)))
			(todochiku-message (format "ERC message from: %s" nick)
			 msg
			 (todochiku-icon 'emacs)
			 nil)))
	nil)
(setq erc-server-PRIVMSG-functions '(c/notify-privmsg erc-server-PRIVMSG))
#+end_src

Growl notification when my nick is mentioned.

#+begin_src emacs-lisp
(defun c/notify-nick-mentioned (match-type nick msg)
	(when (eq match-type 'current-nick)
		(todochiku-message (format "%s mentioned your nick." (car (split-string nick "!")))
					 msg
					 (todochiku-icon 'social)
					 t)))
(add-hook 'erc-text-matched-hook 'c/notify-nick-mentioned)
#+end_src

* Server

Start the server so that we can connect via emacsclient from other
shells.

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
	(server-start))
#+end_src

* I18n
Prefer UTF-8 (mac) wherever possible, and disable cjk. We want this to
override most other settings, therefore add it close to the end.

#+begin_src emacs-lisp
(setq utf-translate-cjk-mode nil)
(set-language-environment 'utf-8)
(set-keyboard-coding-system 'utf-8-mac)
(setq locale-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+end_src

* Footnotes

[1] http://www.gnu.org/software/tramp/#Frequently-Asked-Questions

[2] http://emacs-fu.blogspot.com/2011/08/customizing-mode-line.html

[3] http://groups.google.com/group/gnu.emacs.help/browse_thread/thread/44728fda08f1ec8f?hl=en&tvc=2

[4] http://www.emacswiki.org/emacs/ZapToISearch

[5] http://www.emacswiki.org/emacs/ZapToISearch

[6] http://emacswiki.org/emacs/SearchAtPoint#toc6

[7] http://github.com/defunkt/emacs

[8] http://www.emacswiki.org/emacs/AnythingSources#toc14

[9] http://www.masteringemacs.org/articles/2010/12/13/complete-guide-mastering-eshell/

[10] http://dorophone.blogspot.com/2011/11/how-to-make-emacs-scratch-buffer.html

[11] https://github.com/purcell/emacs.d

[12] http://www.emacswiki.org/

[13] http://www.emacswiki.org/emacs/HalfScrolling#toc2
